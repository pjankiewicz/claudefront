# Strategy Game - Expanded Design Brief

## Game Overview
A single-player, real-time strategy game inspired by OpenFront.io where players dominate a map against AI opponents through territorial expansion, resource management, and strategic decision-making.

## Core Game Mechanics

### 1. Territory Control
- **Map Structure**: Grid-based or region-based map with territories/provinces
- **Ownership**: Players control territories by conquering them from AI opponents
- **Victory Condition**: Dominate the entire map or achieve a percentage threshold (e.g., 70% control)

### 2. Resource Management

#### Population System
- **Total Population**: Current units vs. maximum capacity
- **Population Growth**: Passive generation rate per second/tick
- **Unit Allocation**:
  - **Troops**: Used for attacking and defending
  - **Workers**: Generate gold/income
  - **Slider System**: Dynamic allocation between troops and workers

#### Economy
- **Gold/Currency**: Primary resource for building structures
- **Income Rate**: Generated by workers
- **Cost Scaling**: Buildings and upgrades cost increasing amounts

### 3. Combat System

#### Attack Mechanics
- **Border Requirement**: Can only attack adjacent territories
- **Attack Ratio Slider**: Control what percentage of troops to commit per attack
- **Combat Resolution**:
  - Attacker troops vs. Defender troops
  - Higher attacker:defender ratio = fewer losses for attacker
  - Lower ratio = higher losses for attacker
  - Success requires overwhelming force or sustained pressure

#### Defense Mechanics
- **Passive Defense**: Troops automatically defend owned territories
- **Defense Structures**: Buildings that boost defensive capabilities
- **Multi-front Defense**: Troops distributed across all borders under attack

### 4. Buildings & Upgrades

#### Core Structures
1. **Cities**
   - Increase maximum population cap (+25k or scaled amount)
   - Essential for late-game scaling
   - Limited number per territory or requires specific conditions

2. **Defense Posts**
   - Strengthen border defenses
   - Increase enemy troop losses during attacks
   - Slow down attack speed or reduce effectiveness

3. **Production Buildings** (potential addition)
   - Boost gold generation
   - Increase population growth rate
   - Provide strategic bonuses

### 5. AI Opponent Behavior

#### AI Difficulty Levels
- **Easy**: Passive expansion, poor resource management, predictable attacks
- **Medium**: Balanced expansion, defends strategically, opportunistic attacks
- **Hard**: Aggressive expansion, optimal resource allocation, coordinated attacks

#### AI Strategies
- **Territorial AI**: Focuses on defending and slowly expanding
- **Aggressive AI**: Constantly attacks, sacrifices economy for military
- **Balanced AI**: Mixes defense, expansion, and economy
- **Opportunist AI**: Waits for weak moments to strike

### 6. Game Progression

#### Early Game (0-5 minutes)
- Initial territory with basic population
- Focus on worker ratio for economy
- Scout adjacent territories for weakest targets
- Build first city or defense structures

#### Mid Game (5-15 minutes)
- Multiple territories under control
- Balance between expansion and consolidation
- AI opponents becoming stronger
- Multi-front warfare begins

#### Late Game (15+ minutes)
- Large empire management
- High population caps from cities
- Strategic elimination of remaining AI
- Final push for map domination

## Strategic Depth Elements

### Decision Points
1. **Army vs. Economy**: How many workers vs. troops?
2. **Attack Intensity**: Commit 10%, 25%, 50%, or 100% of troops per attack?
3. **Expansion Direction**: Which neighbor to attack first?
4. **Building Priorities**: Save for city or build defense posts?
5. **Timing**: When to attack vs. when to build up strength?

### Risk-Reward Scenarios
- **Over-expansion**: Control many territories but can't defend them all
- **Turtle Strategy**: Build strong defenses but risk being surrounded
- **Economic Focus**: Prioritize workers but risk being attacked while weak
- **All-in Attack**: Commit all troops to eliminate one opponent, exposing other borders

## Technical Architecture

### Backend (Rust)
- **Game State Management**: Territory ownership, population counts, resource levels
- **Game Loop**: Tick-based updates (e.g., every 100ms)
- **AI Engine**: Decision-making logic for AI opponents
- **Combat Resolution**: Calculate attack outcomes
- **WebSocket Server**: Real-time bidirectional communication

### Frontend (TypeScript/React)
- **Map Rendering**: Visual representation of territories and borders
- **UI Controls**: Sliders for troop/worker ratio and attack intensity
- **Real-time Updates**: Smooth population/resource counters
- **Building Interface**: Construction menus and upgrades
- **Game State Visualization**: Animated attacks, territory captures

### Communication (WebSockets)
- **Client â†’ Server**: Player actions (attack, build, adjust sliders)
- **Server â†’ Client**: Game state updates (population, territories, combat results)
- **Update Frequency**: High-frequency for smooth gameplay

## Clarification Questions

### Gameplay & Balance
1. **Map Design**: Should maps be based on real-world geography (like OpenFront) or procedurally generated? Fixed scenarios or random each game?
Answer: Procedurally generated terrain

2. **AI Count**: How many AI opponents per game? Fixed number or player-selectable (e.g., 2-8 opponents)?
Answer: 8

3. **Game Duration**: Target game length? (5 min, 15 min, 30 min, or variable?)
Answer: Variable

4. **Starting Conditions**: Do all players start equal, or should there be asymmetric starts (some AI start stronger/weaker)?
Answer: Equal

5. **Fog of War**: Can players see all AI territories and their resources, or should there be hidden information?
Answer: No fog of war

### Combat & Balance
6. **Attack Speed**: How long should a single attack take to resolve? Instant, 1 second, 5 seconds?
Answer: variable

7. **Combat Formula**: What should the exact combat math be? Linear, exponential, or with diminishing returns?
Answer: **Linear with advantage multiplier** - Simple for prototype:
  - If attacker > defender: attacker loses 30% of defender's troops, defender loses 100%
  - If attacker < defender: attacker loses 100%, defender loses 50% of attacker's troops
  - If attacker == defender: both lose 70%

8. **Simultaneous Attacks**: Can a player attack multiple territories at once, or one at a time?
Answer: It can attack many territories

9. **Retreating**: Should there be a mechanic to cancel an ongoing attack?
Answer: No

### Buildings & Economy
10. **Building Limits**: Can players build unlimited structures, or should there be caps per territory?
Answer: **1 building per territory** (keeps it simple for prototype)

11. **Building Time**: Should structures build instantly or over time?
Answer: **Instant** (simplifies prototype, can add build time later)

12. **Starting Resources**: How much population and gold should players start with?
Answer: **1000 population, 500 gold** (enough for early expansion + 1 building)

13. **Population Growth**: Should growth be linear or scale with territory count?
Answer: **Scales with territory count** (10 pop/second per territory owned)

14. **Territory Value**: Should different territories provide different bonuses (e.g., mountain = defense, plains = economy)?
Answer: **Yes, basic terrain types**:
  - Plains: +20% gold generation
  - Mountains: +30% defense bonus
  - Forests: +20% population growth
  - Water: No bonus (for map variety)

### Progression & Replay Value
15. **Campaign vs. Skirmish**: Single campaign with progressive difficulty, or standalone skirmish matches?
Answer: **Standalone skirmish** (simpler for prototype, add campaign later)

16. **Progression System**: Should there be unlockable content, or is each game standalone?
Answer: **Standalone** (no persistence for prototype)

17. **Statistics**: Should the game track wins, fastest victories, difficulty beaten?
Answer: **Basic stats only**: game time, territories captured, final score

18. **AI Learning**: Should AI adapt to player strategies within a match, or use fixed behavior patterns?
Answer: **Fixed behavior patterns** (much simpler for prototype)

### UI/UX
19. **Game Speed Control**: Should players be able to pause or adjust game speed?
Answer: **Yes, pause + 1x/2x/4x speed** (essential for single-player)

20. **Visual Style**: Minimalist (like OpenFront), detailed map, abstract representation?
Answer: **Minimalist** (faster to implement, focus on gameplay)

21. **Notifications**: Should players get alerts for attacks, low resources, buildings completed?
Answer: **Yes, basic notifications**: "Under Attack!", "Territory Captured", "Building Complete"

22. **Accessibility**: Touch controls for mobile, or desktop-only initially?
Answer: **Desktop-only initially** (mouse + keyboard, add touch later)

### Technical
23. **Save/Load**: Should games be saveable mid-match?
Answer: **No** (not essential for prototype, games are time-limited)

24. **Replay System**: Record and replay matches?
Answer: **No** (future enhancement)

25. **Performance**: Target player count and territory count for performance testing?
Answer: **9 players (1 human + 8 AI), 50-100 territories** (reasonable for prototype)

## Next Steps

Once clarification questions are answered:
1. Define exact combat formulas and balance parameters
2. Design initial map layouts or generation algorithm
3. Specify AI decision-making logic in detail
4. Create wireframes for UI controls and layout
5. Set up project structure for Rust backend + React frontend
6. Implement basic game loop and WebSocket communication
7. Build minimal viable product (single map, one AI, basic mechanics)
8. Iterate on balance and AI behavior
9. Add buildings, multiple AI opponents, and additional maps
10. Polish and test for release

## Scope Recommendations

### MVP (Minimum Viable Product)
- Single fixed map with 3-5 territories per player
- 1 AI opponent (medium difficulty)
- Core mechanics: population, troops/workers, attacking, basic defense
- Simple UI with sliders and click-to-attack
- 1 building type (City for population cap)

### Version 1.0
- 3-5 different maps
- 3 AI difficulty levels
- 2-4 AI opponents per match
- All building types (Cities, Defense Posts, Production)
- Polished UI with animations
- Victory/defeat screens with statistics

### Future Enhancements
- Campaign mode with progressive scenarios
- Additional building types and upgrades
- Special abilities or power-ups
- Map editor
- Procedural map generation
- Multiplayer support (stretch goal)

My comments:
- Rust must use utoipa
- Rust backend must expose / generate SDK types for frontend so everything is typesafe

## Technical Implementation Details

### Type-Safe Architecture (Rust â†’ TypeScript)

#### Rust Backend Stack
- **utoipa**: OpenAPI schema generation from Rust types
- **utoipa-swagger-ui**: Auto-generated API documentation
- **serde**: Serialization/deserialization
- **tokio-tungstenite**: WebSocket server
- **axum**: HTTP server framework (integrates well with utoipa)

#### Type Generation Workflow
1. **Define Rust types** with `#[derive(ToSchema)]` from utoipa:
   ```rust
   #[derive(Serialize, Deserialize, ToSchema)]
   struct GameState {
       territories: Vec<Territory>,
       players: Vec<Player>,
       tick: u64,
   }
   ```

2. **Generate OpenAPI spec** automatically from utoipa annotations

3. **Generate TypeScript types** using one of:
   - `openapi-typescript` - generates types from OpenAPI spec
   - `typeshare` - alternative that directly generates TS from Rust
   - Build script that runs after Rust compilation

4. **Import in React frontend**:
   ```typescript
   import { GameState, Territory, Player } from './generated/api-types';
   ```

#### WebSocket Message Types
All WebSocket messages must be strongly typed on both ends:

**Client â†’ Server Messages:**
```rust
#[derive(Serialize, Deserialize, ToSchema)]
#[serde(tag = "type")]
enum ClientMessage {
    Attack { from: TerritoryId, to: TerritoryId, troops: u32 },
    BuildStructure { territory: TerritoryId, building_type: BuildingType },
    SetTroopRatio { ratio: f32 },
    SetAttackRatio { ratio: f32 },
    PauseGame,
    SetGameSpeed { speed: f32 },
}
```

**Server â†’ Client Messages:**
```rust
#[derive(Serialize, Deserialize, ToSchema)]
#[serde(tag = "type")]
enum ServerMessage {
    GameStateUpdate { state: GameState },
    AttackResult { success: bool, attacker_losses: u32, defender_losses: u32 },
    TerritoryConquered { territory_id: TerritoryId, new_owner: PlayerId },
    Notification { message: String, severity: NotificationLevel },
    GameOver { winner: PlayerId, stats: GameStats },
}
```

#### SDK Generation Process

**build.rs** or separate script:
```rust
// In build.rs or standalone tool
use utoipa::OpenApi;

#[derive(OpenApi)]
#[openapi(
    components(schemas(
        GameState,
        Territory,
        Player,
        ClientMessage,
        ServerMessage,
        // ... all types
    ))
)]
struct ApiDoc;

fn main() {
    let openapi = ApiDoc::openapi();
    std::fs::write(
        "../frontend/src/generated/openapi.json",
        serde_json::to_string_pretty(&openapi).unwrap()
    ).unwrap();
}
```

**Frontend build step** (package.json):
```json
{
  "scripts": {
    "generate-types": "openapi-typescript ../backend/openapi.json -o src/generated/api-types.ts",
    "prebuild": "npm run generate-types"
  }
}
```

#### Project Structure
```
strategy_game/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”œâ”€â”€ game/
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ state.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ combat.rs
â”‚   â”‚   â”‚   â””â”€â”€ ai.rs
â”‚   â”‚   â”œâ”€â”€ types/          # All utoipa-annotated types
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ messages.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ game_state.rs
â”‚   â”‚   â”‚   â””â”€â”€ entities.rs
â”‚   â”‚   â””â”€â”€ websocket.rs
â”‚   â””â”€â”€ build.rs            # OpenAPI generation
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ generated/      # Auto-generated TypeScript types
â”‚   â”‚   â”‚   â””â”€â”€ api-types.ts
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ App.tsx
â”‚   â””â”€â”€ vite.config.ts
â””â”€â”€ docs/
    â””â”€â”€ brief_expanded.md
```

### Benefits of This Architecture
1. **Compile-time safety**: TypeScript errors if Rust types change
2. **Single source of truth**: Rust types define the API contract
3. **Auto-generated docs**: utoipa creates Swagger UI automatically
4. **Zero drift**: Frontend always matches backend types
5. **Refactoring confidence**: Rename a field in Rust, get TS errors everywhere it's used

### Development Workflow
1. Define/modify Rust types in `backend/src/types/`
2. Run `cargo build` â†’ triggers build.rs â†’ generates openapi.json
3. Run `npm run generate-types` in frontend â†’ generates TypeScript types
4. TypeScript compiler catches any mismatches immediately
5. Both frontend and backend compile with full type safety

## Game Balance & Interesting Mechanics

### Core Balance Parameters

#### Population & Economy
- **Starting**: 1000 population, 500 gold, 1 territory
- **Population growth**: 10/sec per territory + terrain bonuses
- **Worker gold generation**: 1 gold per 10 workers per second
- **Max population cap**: 10,000 base, +25,000 per City building

#### Combat Math (Detailed)
```
troops_committed = total_troops * attack_ratio

If attacker_troops > defender_troops:
  attacker_losses = defender_troops * 0.3
  defender_losses = defender_troops * 1.0

If attacker_troops < defender_troops:
  attacker_losses = attacker_troops * 1.0
  defender_losses = attacker_troops * 0.5

If attacker_troops == defender_troops:
  attacker_losses = attacker_troops * 0.7
  defender_losses = defender_troops * 0.7

Apply terrain defense bonus to defender_losses (reduce by 30% for mountains)
Apply Defense Post bonus if present (reduce defender_losses by additional 20%)
```

#### Building Costs & Effects
1. **City**
   - Cost: 1000 gold
   - Effect: +25,000 max population
   - Strategy: Essential for late-game dominance

2. **Defense Post**
   - Cost: 500 gold
   - Effect: +20% defense (reduces defender losses)
   - Strategy: Build on borders with aggressive AI

3. **Gold Mine** (new suggestion)
   - Cost: 750 gold
   - Effect: +50% gold generation from workers in this territory
   - Strategy: Build early for economic snowball

### Strategic Depth: The Interesting Decisions

#### Early Game Dilemmas (0-3 minutes)
1. **Economic vs Military Start**
   - High worker ratio (80%+) = faster gold, vulnerable to attacks
   - High troop ratio (60%+) = safer but slower growth
   - Balanced (50/50) = moderate growth and defense

2. **First Expansion Target**
   - Attack weakest AI = easy win, low reward
   - Attack AI on resource-rich terrain (plains) = harder, better long-term
   - Attack multiple weak territories simultaneously = risky but fast expansion

3. **First Building Decision**
   - City = long-term investment, need to defend it
   - Defense Post = safety, but slows economic growth
   - Gold Mine = economic boom, but need troops to protect it

#### Mid Game Tension (3-10 minutes)
1. **Multi-Front Warfare**
   - Focus all attacks on one AI = eliminate threat but ignore others growing
   - Spread attacks evenly = slow everyone down but don't eliminate anyone
   - Temporary "truces" = focus one enemy while others grow

2. **Building Placement Strategy**
   - Cities in core territories = safe but less aggressive
   - Cities on borders = risky but enables faster expansion
   - Defense Posts on all borders = turtle strategy, hard to break

3. **Over-Extension Risk**
   - Control many territories = high income but thin defenses
   - AI can break through and capture multiple territories rapidly
   - Need to identify and reinforce weak points

#### Late Game Climax (10+ minutes)
1. **Final Showdowns**
   - 2-3 powerful AI remaining with large armies
   - Picking the right target order is critical
   - One mistake can lead to losing hard-earned territories

2. **Population Management**
   - High troop ratio = strong attacks but slow economy
   - Need to balance aggression with growth for final push

3. **Territory Consolidation**
   - Recapture lost territories while pushing forward
   - Prevent AI from regaining strength

### AI Personality Types (Makes Game Interesting)

#### 1. The Turtle (Defensive AI)
- **Behavior**: High worker ratio early, builds Defense Posts everywhere
- **Threat**: Hard to attack, becomes economic powerhouse
- **Counter**: Attack early before they fortify, or ignore and expand elsewhere

#### 2. The Aggressor (Offensive AI)
- **Behavior**: High troop ratio, attacks neighbors constantly
- **Threat**: Can eliminate other AI quickly, snowballs out of control
- **Counter**: Let them fight other AI, then attack when they're weakened

#### 3. The Balanced (Adaptive AI)
- **Behavior**: Matches player strategy, adjusts ratios based on threats
- **Threat**: No obvious weakness, steady growth
- **Counter**: Commit fully to either economy or military to outpace them

#### 4. The Opportunist (Sneaky AI)
- **Behavior**: Attacks weakest neighbors, avoids strong players
- **Threat**: Expands quietly while you're distracted
- **Counter**: Maintain strong borders, don't show weakness

#### 5. The Rusher (Kamikaze AI)
- **Behavior**: 100% troops, attacks immediately with everything
- **Threat**: Can eliminate a player in first 2 minutes
- **Counter**: Build Defense Post immediately, high troop ratio initially

### Procedural Map Generation Rules

#### Map Layout
- **Territory count**: 50-100 territories
- **Starting positions**: Evenly distributed around map edges
- **Territory size**: Varies randomly for visual interest
- **Connections**: Each territory connects to 3-6 neighbors (no isolated territories)

#### Terrain Distribution
- **40% Plains**: Economic territories (clustered)
- **25% Mountains**: Defensive territories (border regions)
- **25% Forests**: Population growth territories (scattered)
- **10% Water**: Visual variety, no bonus (separates regions)

#### Strategic Map Features
1. **Chokepoints**: 2-3 narrow passages that control access to regions
2. **Resource Clusters**: Groups of 3-4 plains territories (high value targets)
3. **Mountain Ranges**: Natural defensive barriers separating players
4. **Center Control**: 5-7 high-value territories in map center

#### Victory Conditions
- **Domination**: Control 100% of territories
- **Time-based**: Highest territory count after 20 minutes
- **Score-based**: First to 10,000 points (territories + buildings + gold/1000)

### Pacing & Progression

#### Game Phases
1. **Setup (0-1 min)**: Player adjusts initial ratios, scouts neighbors
2. **Early Expansion (1-3 min)**: First attacks, 1-2 territories captured
3. **First Contact (3-5 min)**: AI start attacking each other and player
4. **Mid Game Chaos (5-10 min)**: Multiple fronts, territory trading hands
5. **Consolidation (10-15 min)**: 3-4 players remain, building economies
6. **Endgame (15-20 min)**: Final battles between 2-3 strongest players
7. **Victory (20+ min)**: Player or AI achieves victory condition

### What Makes This Game Interesting?

1. **Real-time Tension**: Can't pause to think (even with speed control, game keeps moving)
2. **Micro-Management**: Constantly adjusting troop/worker ratio
3. **Macro Strategy**: Choosing which AI to attack, where to build, when to defend
4. **Risk-Reward**: Every decision has tradeoffs (attack now vs build economy?)
5. **AI Variety**: Each game plays differently based on AI personalities
6. **Comeback Potential**: Losing territories isn't game over, can rebuild
7. **Multiple Paths**: Turtle, rush, balanced, opportunist all viable
8. **Emergent Drama**: Watching AI fight each other, alliances forming/breaking
9. **Quick Iteration**: Games are 10-20 minutes, can try different strategies

### Key Success Metrics for Prototype

- **Engagement**: Do players want to play "just one more game"?
- **Strategic Depth**: Can skilled players win consistently vs AI?
- **Balance**: Can multiple strategies succeed, or is one dominant?
- **Pacing**: Does the game feel too slow or too fast?
- **AI Quality**: Do AI feel like real opponents, not robots?